#! /usr/bin/python

import socket
import select

LISTEN_PORT = 6600
TARGET_PORT = 6601

dispatchers = {}
buffers = {}
files = {}

# FIXME figure out how to prefix direction etc...

def main():
    setup_listener()
    
    while True:
        socks = dispatchers.keys()
        read, write, error = select.select(socks, socks, [])
        for sock in read:
            dispatchers[sock]()
        for sock in write:
            send(sock)

def setup_listener():
    listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listener.setblocking(0)
    listener.bind(('', LISTEN_PORT))
    listener.listen(1)

    dispatchers[listener] = lambda: handle_listener(listener)

def create_connection():
    connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    connection.connect(('', TARGET_PORT))
    return connection

def create_file():
    # FIXME new file per connection, use time as name?
    # FIXME write comment header explainging syntax
    return open('/tmp/test', 'w')

def handle_listener(sock): 
    client, addr = sock.accept()
    server = create_connection()
    file = create_file()

    buffers[client] = ''
    buffers[server] = ''

    dispatchers[client] = lambda: handle_proxy(client, server)
    dispatchers[server] = lambda: handle_proxy(server, client)

    files[client] = file
    files[server] = file

def handle_proxy(source, dest):
    try:
        data = source.recv(8192)
    except socket.error, e:
        data = ''

    if len(data):
        print data,
        buffers[dest] = data
    else:
        cleanup(source)
        cleanup(dest)
        

def cleanup(sock):
    if not files[sock].closed:
        files[sock].close()
    del files[sock]
    del dispatchers[sock]
    del buffers[sock]
    sock.close()

def send(sock):
    if sock not in buffers:
        return

    transmited = sock.send(buffers[sock])
    files[sock].write(buffers[sock][:transmited])
    buffers[sock] = buffers[sock][transmited:]

if __name__ == '__main__':
    main()
